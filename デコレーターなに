"""
============================================================
ステップ1: デコレーターとは何か？
============================================================

デコレーターは「関数を装飾（デコレート）する関数」です。
@マークを使って、既存の関数に新しい機能を追加できます。
"""

# ===================================================================
# 1-1. デコレーターなしのコード（Before）
# ===================================================================

def greet(name):
    """挨拶する関数"""
    print(f"こんにちは、{name}さん！")

# 関数を呼ぶ
greet("田中")
# 出力: こんにちは、田中さん！


# ===================================================================
# 1-2. ログを追加したい場合（デコレーターなし）
# ===================================================================

def greet_with_log(name):
    """挨拶する関数（ログ付き）"""
    print("[LOG] greet関数が呼ばれました")  # ← この行を毎回書く必要がある
    print(f"こんにちは、{name}さん！")
    print("[LOG] greet関数が終了しました")  # ← この行も毎回書く必要がある

greet_with_log("佐藤")
# 出力:
# [LOG] greet関数が呼ばれました
# こんにちは、佐藤さん！
# [LOG] greet関数が終了しました


# ===================================================================
# 1-3. デコレーターを使う場合（After）
# ===================================================================

# まず、デコレーターを定義
def add_log(func):
    """ログを追加するデコレーター"""
    def wrapper(*args, **kwargs):
        print(f"[LOG] {func.__name__}関数が呼ばれました")
        result = func(*args, **kwargs)  # 元の関数を実行
        print(f"[LOG] {func.__name__}関数が終了しました")
        return result
    return wrapper


# デコレーターを使って関数を装飾
@add_log
def greet_decorated(name):
    """挨拶する関数（デコレーター使用）"""
    print(f"こんにちは、{name}さん！")


# 普通に関数を呼ぶだけ！
greet_decorated("鈴木")
# 出力:
# [LOG] greet_decorated関数が呼ばれました
# こんにちは、鈴木さん！
# [LOG] greet_decorated関数が終了しました


"""
============================================================
ポイント1: デコレーターの仕組み
============================================================

@add_log
def greet_decorated(name):
    print(f"こんにちは、{name}さん！")

↓ これは以下と同じ意味

def greet_decorated(name):
    print(f"こんにちは、{name}さん！")

greet_decorated = add_log(greet_decorated)

つまり、デコレーターは「関数を受け取って、新しい関数を返す」関数です。
"""


# ===================================================================
# 1-4. デコレーターの構造を理解する
# ===================================================================

def my_decorator(func):
    """
    デコレーターのテンプレート
    
    Args:
        func: デコレートする関数
    
    Returns:
        wrapper: ラップされた新しい関数
    """
    # ステップ1: wrapper関数を定義
    def wrapper(*args, **kwargs):
        # ステップ2: 元の関数の前に実行する処理
        print("--- 関数実行前 ---")
        
        # ステップ3: 元の関数を実行
        result = func(*args, **kwargs)
        
        # ステップ4: 元の関数の後に実行する処理
        print("--- 関数実行後 ---")
        
        # ステップ5: 結果を返す
        return result
    
    # ステップ6: wrapper関数を返す
    return wrapper


# 使用例
@my_decorator
def say_hello():
    print("Hello!")

say_hello()
# 出力:
# --- 関数実行前 ---
# Hello!
# --- 関数実行後 ---


"""
============================================================
ポイント2: *args と **kwargs
============================================================

*args:  位置引数を全て受け取る
**kwargs: キーワード引数を全て受け取る

これにより、どんな引数の関数にも対応できます。

例:
    def wrapper(*args, **kwargs):
        func(*args, **kwargs)
    
    # 以下の全てに対応可能
    func()              # 引数なし
    func(1, 2, 3)       # 位置引数
    func(a=1, b=2)      # キーワード引数
    func(1, 2, c=3)     # 混在
"""


# ===================================================================
# 1-5. 実践例：時間計測デコレーター
# ===================================================================

import time

def measure_time(func):
    """実行時間を計測するデコレーター"""
    def wrapper(*args, **kwargs):
        # 開始時刻を記録
        start_time = time.time()
        
        # 元の関数を実行
        result = func(*args, **kwargs)
        
        # 終了時刻を記録
        end_time = time.time()
        
        # 実行時間を計算
        elapsed_time = end_time - start_time
        print(f"[TIME] {func.__name__}の実行時間: {elapsed_time:.4f}秒")
        
        return result
    
    return wrapper


@measure_time
def slow_function():
    """時間のかかる処理"""
    time.sleep(1)
    print("処理完了")

slow_function()
# 出力:
# 処理完了
# [TIME] slow_functionの実行時間: 1.0012秒


"""
============================================================
ステップ1のまとめ
============================================================

✅ デコレーターは「関数を受け取って、新しい関数を返す」関数
✅ @マークで簡潔に書ける
✅ *args, **kwargs でどんな関数にも対応
✅ 元の関数の前後に処理を追加できる

次のステップ: functools.wraps を使って完璧なデコレーターを作る
"""
